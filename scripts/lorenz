#!/usr/bin/env python
# -*- coding: utf-8 -*-
# lorenz
# Copyright (c) 2020 Hugh Coleman
#
# This file is part of hughcoleman/lorenz, a historically accurate simulator of
# the Lorenz SZ40 Cipher Machine. It is released under the MIT License (see
# LICENSE.)
import argparse

import lorenz.machine

# import auxillary devices
import lorenz.patterns
import lorenz.telegraphy

def parse(settings):
    """ Parse the notation in the command-line parameters. """

    # This regular expression (generally) matches the format below.
    # 
    #     S1-S2-S3-S4-S5,M37-M61,X1-X2-X3-X4-X5
    #
    # Valid separators are commas and dashes. So long as a consistent separator 
    # is used to separate rotors from other rotors in the same group, and 
    # groups of rotors from each other, then it will be matched.
    # 
    # Validating the numerals in each "slot" is handled later, so that the user
    # can be provided decent feedback as to what is wrong with their notation.
        
    notation = re.compile(
        r"\b(\d+)([\-,])(\d+)\2(\d+)\2(\d+)\2(\d+)([\-,])(\d+)\2(\d+)\7(\d+)\2(\d+)\2(\d+)\2(\d+)\2(\d+)\b"
    )

    if not (groups := re.search(notation, settings)):  # noqa: E231
        raise ValueError("Unrecognized positions format.")

    # filter out separators and cast to int.
    positions = [
        int(position) for position in groups.groups() if position.isdigit()
    ]
    
    # check the ensure the positions are within the acceptable bounds - this is
    # a list of tuples, rather than a dictionary, to ensure consistent 
    # iteration order across different Python interpreters.
    rotors = [
        ("psi1", 43),
        ("psi2", 47),
        ("psi3", 51),
        ("psi4", 53),
        ("psi5", 59),
        ("mu37", 37),
        ("mu61", 61),
        ("chi1", 41),
        ("chi2", 31),
        ("chi3", 29),
        ("chi4", 26),
        ("chi5", 23)
    ]
    
    for (rotor, size), position in zip(rotors, positions):
        if position <= 0 or position > size:
            raise ValueError(f"Position of {rotor} rotor is outside of the allowed bounds (1-{size}).")
    
    return positions
    
if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    # configure: machine operating mode
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "-e", "--encrypt", action="store_true", help="perform an encryption"
    )
    group.add_argument(
        "-d", "--decrypt", action="store_true", help="perform a decryption"
    )

    # configure: machine cipher settings
    parser.add_argument("-c", "--cams", help="cam patterns")
    parser.add_argument("-p", "--positions", help="rotor positions, in standard german format")

    # configure: input stream
    parser.add_argument(
        "input",
        type=argparse.FileType("r"),
        help="input text to encrypt/decrypt",
    )

    args = parser.parse_args()

    # Create an instance of SZ40 with the supplied parameters.
    machine = lorenz.machine.SZ40(None)
